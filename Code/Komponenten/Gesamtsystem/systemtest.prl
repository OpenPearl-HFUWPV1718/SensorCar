

MODULE(system);
	SYSTEM;
		stdout: StdOut;
		lichtrechen: RPiDigitalIn(13,8,'u');

		leftstepmotor_out: RPiDigitalOut(19, 4);
		rightstepmotor_out: RPiDigitalOut(23, 4);

	PROBLEM;
		SPC stdout DATION OUT SYSTEM ALPHIC;
		DCL termout DATION OUT ALPHIC DIM(*, 80) FORWARD STREAM CREATED(stdout);		

		SPC lichtrechen DATION IN SYSTEM BASIC BIT(8) GLOBAL;
		DCL lr DATION IN BASIC BIT(8) CREATED(lichtrechen);
		
		SPC leftstepmotor_out DATION OUT SYSTEM BASIC BIT(4) GLOBAL;
		DCL lmotor DATION OUT BASIC BIT(4) CREATED (leftstepmotor_out);
		SPC rightstepmotor_out DATION OUT SYSTEM BASIC BIT(4) GLOBAL;
		DCL rmotor DATION OUT BASIC BIT(4) CREATED (rightstepmotor_out);
    
    DCL (lr_signal) FLOAT;
    DCL (lm_speed, rm_speed) FLOAT;
    
    DCL (lr_sema, lm_sema, rm_sema, d1, d2) SEMA PRESET(1,1,1,0,0);
    
    DCL (lspeed, rspeed) FLOAT INIT(1,1);

	main: TASK MAIN;
		lr_signal := 0;
		lm_speed := 1;
		rm_speed := 1;
		
		OPEN termout;
		OPEN lmotor;
		OPEN rmotor;
		ACTIVATE readlr;
		ACTIVATE drive;
		SUSPEND;
		CLOSE lmotor;
		CLOSE rmotor;
		CLOSE termout;
	
	END;
		
  drive: TASK;
     DCL lrin FLOAT;
     DCL in FLOAT;
     
     REPEAT
     REQUEST lr_sema;
     in:= -1 * lr_signal;
     RELEASE lr_sema;
     
     IF in < 0 THEN
      lspeed := 1;
      rspeed := -1 * in;
     FIN;
     
     IF in > 0 THEN
      lspeed = in;
      rspeed = 1;
     FIN;
     
     IF in == 0 THEN
        lspeed = 1;
        rspeed = 1;
     FIN;
     
     REQUEST lm_sema;
     lm_speed = lspeed;
     RELEASE lm_sema;
     
     REQUEST rm_sema;
     rm_speed = rspeed;
     RELEASE rm_sema;
     
     ACTIVATE driveleft;
     ACTIVATE driveright;
     REQUEST d1, d2;
     END;
  END;
  
  driveleft: TASK;
    DCL default DUR INIT(0.05 SEC);
    DCL time DUR;
    DCL speed FLOAT;

    REQUEST lm_sema;
    speed := lm_speed;
    RELEASE lm_sema;
    time := (1 / speed) * default;

    PUT 'linker Motor: ', speed TO termout BY A, F(6), SKIP;
    CALL step(0, 1, 1, time);
    RELEASE d1;
  END;
  
  driveright: TASK;
    DCL default DUR INIT(0.05 SEC);
    DCL time DUR;
    DCL speed FLOAT;

    REQUEST rm_sema;
    speed := rm_speed;
    RELEASE rm_sema;
    time := (1 / speed) * default;

    PUT 'rechter Motor: ', speed TO termout BY A, F(6), SKIP;

    CALL step(1, 1, 1, time);
    RELEASE d2;
  END;

  
  
	readlr: TASK;
		DCL bits BIT(8);
		DCL timeinterval DUR;
		DCL out FLOAT;
		DCL count FIXED;
		OPEN lr;
		timeinterval := 0.01 SEC;
		REPEAT
			out := 0;
			count := 0;
			TAKE bits FROM lr;

			!PUT bits, bits TO terminal BY B4(2), X, B1(8), SKIP;
			IF bits.BIT(1) == '1'B
			THEN
				out := out + 4;
				count := count +1;
			FIN ;
			IF bits.BIT(2) == '1'B
			THEN
				out := out + 3;
				count := count +1;
			FIN ;
			IF bits.BIT(3) == '1'B
			THEN
				out := out + 2;
				count := count +1;
			FIN ;
			IF bits.BIT(4) == '1'B
			THEN
				out := out + 1;
				count := count +1;			
			FIN ;
			IF bits.BIT(5) == '1'B
			THEN
				out := out - 1;
				count := count +1;
			FIN ;
			IF bits.BIT(6) == '1'B
			THEN
				out := out - 2;
				count := count +1;
			FIN ;
			IF bits.BIT(7) == '1'B
			THEN
				out := out - 3;
				count := count +1;
			FIN ;
			IF bits.BIT(8) == '1'B			
			THEN
				out := out - 4;
				count := count +1;
			FIN ;
			IF count /= 0
			THEN
				out := out / count;
			FIN ;
      REQUEST lr_sema;
			lr_signal := out;
      RELEASE lr_sema;
			AFTER timeinterval RESUME;
		END;
		CLOSE lr;
	END;


	step: PROC(motorindex FIXED, steps FIXED, dir FIXED, time DUR);
	  DCL (a, b ) BIT(4) INIT('1010'B1, '1001'B1);
	  DCL (c,d) BIT(4);
	  c := '0101'B1;
	  d := '0110'B1;
	  IF motorindex == 0 THEN
		IF dir == 0 THEN
		   TO steps REPEAT
			 SEND a TO lmotor;
			 AFTER time RESUME;

			 SEND b TO lmotor;
			 AFTER time RESUME;

			 SEND c TO lmotor;
			 AFTER time RESUME;

			 SEND d TO lmotor;
			 AFTER time RESUME;
		   END;
		FIN;

		IF dir == 1 THEN
		   TO steps REPEAT
			 SEND d TO lmotor;
			 AFTER time RESUME;

			 SEND c TO lmotor;
			 AFTER time RESUME;

			 SEND b TO lmotor;
			 AFTER time RESUME;

			 SEND a TO lmotor;
			 AFTER time RESUME;
		   END;
		FIN;
	  FIN;
	  IF motorindex == 1 THEN
		IF dir == 0 THEN
		   TO steps REPEAT
			 SEND a TO rmotor;
			 AFTER time RESUME;

			 SEND b TO rmotor;
			 AFTER time RESUME;

			 SEND c TO rmotor;
			 AFTER time RESUME;

			 SEND d TO rmotor;
			 AFTER time RESUME;
		   END;
		FIN;

		IF dir == 1 THEN
		   TO steps REPEAT
			 SEND d TO rmotor;
			 AFTER time RESUME;

			 SEND c TO rmotor;
			 AFTER time RESUME;

			 SEND b TO rmotor;
			 AFTER time RESUME;

			 SEND a TO rmotor;
			 AFTER time RESUME;
		   END;
		FIN;
	  FIN;
	END;
	
	
	


MODEND;
