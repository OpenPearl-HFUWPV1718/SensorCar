MODULE(system);
	SYSTEM;
		stdin:StdIn;
		stdout:StdOut;
		
		lichtrechen: RPiDigitalIn(13,8,'u');

		leftstepmotor_out: RPiDigitalOut(19, 4);
		rightstepmotor_out: RPiDigitalOut(23, 4);

	PROBLEM;
		SPC stdout DATION OUT SYSTEM ALPHIC;
		DCL termout DATION OUT ALPHIC DIM(*,80) FORWARD STREAM CREATED(stdout);
				
		SPC stdin DATION IN SYSTEM ALPHIC;
		DCL termin DATION IN ALPHIC DIM(*,80) FORWARD STREAM CREATED(stdin);


		SPC lichtrechen DATION IN SYSTEM BASIC BIT(8) GLOBAL;
		DCL lr DATION IN BASIC BIT(8) CREATED(lichtrechen);
		DCL lrout FLOAT;
		
		SPC leftstepmotor_out DATION OUT SYSTEM BASIC BIT(4) GLOBAL;
		DCL lmotor DATION OUT BASIC BIT(4) CREATED (leftstepmotor_out);
		SPC rightstepmotor_out DATION OUT SYSTEM BASIC BIT(4) GLOBAL;
		DCL rmotor DATION OUT BASIC BIT(4) CREATED (rightstepmotor_out);
		DCL speed FLOAT;

	main: TASK MAIN;
		lrout := 0;
		speed := 0;
		
		ACTIVATE readlr;
		ACTIVATE driver;
		ACTIVATE drivel;
		ACTIVATE commands;
		
	
	END;
	
	commands: TASK;
		OPEN termout;
		OPEN termin;
		REPEAT
			DCL command FIXED;
			GET command FROM termin BY F(6), SKIP;
			IF command == 0
			THEN
				PUT 'Command 0: stop'  TO termout BY A, SKIP;
				speed := 0;
			FIN;
			IF command == 1
			THEN
				PUT 'Command 1: forward'  TO termout BY A, SKIP;
				speed := 1;
			FIN;
			IF command == 2
			THEN
				PUT 'Command 2: reverse'  TO termout BY A, SKIP;
				speed := -1;
			FIN;
			IF command == 3
			THEN		
				speed := 1;
				AFTER 1SEC RESUME;
				speed := -1;
				AFTER 1SEC RESUME;
				speed := 0;
			FIN;
		END;
		CLOSE termout;
		CLOSE termin;
			
			
	END;
		
		
	readlr: TASK;
		DCL bits BIT(8);
		DCL timeinterval DUR;
		DCL out FLOAT;
		DCL count FIXED;
		OPEN lr;
		timeinterval := 0.01 SEC;
		REPEAT
			out := 0;
			count := 0;
			TAKE bits FROM lr;

			!PUT bits, bits TO terminal BY B4(2), X, B1(8), SKIP;
			IF bits.BIT(1) == '1'B
			THEN
				out := out + 4;
				count := count +1;
			FIN ;
			IF bits.BIT(2) == '1'B
			THEN
				out := out + 3;
				count := count +1;
			FIN ;
			IF bits.BIT(3) == '1'B
			THEN
				out := out + 2;
				count := count +1;
			FIN ;
			IF bits.BIT(4) == '1'B
			THEN
				out := out + 1;
				count := count +1;			
			FIN ;
			IF bits.BIT(5) == '1'B
			THEN
				out := out - 1;
				count := count +1;
			FIN ;
			IF bits.BIT(6) == '1'B
			THEN
				out := out - 2;
				count := count +1;
			FIN ;
			IF bits.BIT(7) == '1'B
			THEN
				out := out - 3;
				count := count +1;
			FIN ;
			IF bits.BIT(8) == '1'B			
			THEN
				out := out - 4;
				count := count +1;
			FIN ;
			IF count /= 0
			THEN
				out := out / count;
			FIN ;
			lrout := out;
			AFTER timeinterval RESUME;
		END;
		CLOSE lr;
	END;
		
		

	driver: TASK;
		REPEAT
		  DCL time DUR INIT (0.01 SEC);
		  DCL tempsteps FLOAT;
		  DCL steps FIXED;
		  OPEN rmotor;
		  REPEAT;
			tempsteps := speed*(10+lrout);
			steps := ROUND(tempsteps);
			CALL step(0, steps, 0, time);
		  END;
		  CLOSE rmotor;
		END;
	END;
	
	drivel: TASK;
		REPEAT
		  DCL time DUR INIT (0.01 SEC);
		  DCL tempsteps FLOAT;
		  DCL steps FIXED;
		  OPEN lmotor;
		  REPEAT;
			tempsteps := speed*(10+lrout);
			steps := ROUND(tempsteps);
			CALL step(1, steps, 0, time);
		  END;
		  CLOSE lmotor;
		END;
	END;

	step: PROC(motorindex FIXED, steps FIXED, dir FIXED, time DUR);
	  DCL (a, b ) BIT(4) INIT('1010'B1, '1001'B1);
	  DCL (c,d) BIT(4);
	  c := '0101'B1;
	  d := '0110'B1;
	  IF motorindex == 0 THEN
		IF dir == 0 THEN
		   TO steps REPEAT
			 SEND a TO lmotor;
			 AFTER time RESUME;

			 SEND b TO lmotor;
			 AFTER time RESUME;

			 SEND c TO lmotor;
			 AFTER time RESUME;

			 SEND d TO lmotor;
			 AFTER time RESUME;
		   END;
		FIN;

		IF dir == 1 THEN
		   TO steps REPEAT
			 SEND d TO lmotor;
			 AFTER time RESUME;

			 SEND c TO lmotor;
			 AFTER time RESUME;

			 SEND b TO lmotor;
			 AFTER time RESUME;

			 SEND a TO lmotor;
			 AFTER time RESUME;
		   END;
		FIN;
	  FIN;
	  IF motorindex == 1 THEN
		IF dir == 0 THEN
		   TO steps REPEAT
			 SEND a TO rmotor;
			 AFTER time RESUME;

			 SEND b TO rmotor;
			 AFTER time RESUME;

			 SEND c TO rmotor;
			 AFTER time RESUME;

			 SEND d TO rmotor;
			 AFTER time RESUME;
		   END;
		FIN;

		IF dir == 1 THEN
		   TO steps REPEAT
			 SEND d TO rmotor;
			 AFTER time RESUME;

			 SEND c TO rmotor;
			 AFTER time RESUME;

			 SEND b TO rmotor;
			 AFTER time RESUME;

			 SEND a TO rmotor;
			 AFTER time RESUME;
		   END;
		FIN;
	  FIN;
	END;
MODEND;
