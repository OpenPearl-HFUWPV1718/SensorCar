\chapter{Komponenten}
\label{komponenten}
\section{Raspberry Pi 3}
Als Entwicklungs- und Zielplattform wird ein Raspberry Pi 3 genutzt, auf dem OpenPEARL installiert ist. Die Sensoren und Aktoren sollen wie in Tabelle \ref{tab:anschlussplan} am Raspberry Pi angeschlossen werden:

\begin{table} [H]
	\begin{center}
		 \renewcommand{\arraystretch}{1.5}
		\begin{tabular}{|l|l|l|}
			\hline
			\textbf{Gerät} & \textbf{BCM} & \textbf{Versorgung}\\
			\hline
			Lichtrechen & 6 -- 13 & 3,5 / 5V\\
			\hline
			Motortreiber& 16 -- 19, 20 -- 23 & extern\\
			\hline
			Farbsensor & 2, 3 (I$^2$C) & 3,3 / 5V\\
			\hline
			Gyroskop & 2, 3 (I$^2$C) & 5V\\
			\hline
			Kompass & 2, 3 (I$^2$C) & 5V\\
			\hline
			LEDs & 24 -- & 5V\\
			\hline
		\end{tabular}
	\end{center}
\caption{Anschlussplan Raspberry Pi}\label{tab:anschlussplan}
\end{table}

Der zugrundeliegende Belegungsplan ist im Anhang \ref{Belegungsplan} zu finden.


\section{Schrittmotor}
Die Schrittmotoren werden jeweils über einen Motortreiber und vier GPIO-Pins des Raspberry Pi angesteuert. Energie erhält der Motor durch ein an den Treiber angeschlossenes Netzteil mit 12V Gleichstrom. Durch paarweise Alternieren der Bits an den vier GPIO-Pins wird der Schrittmotor um jeweils einen Schritt bewegt. Es ergibt sich das Bitmuster in Tabelle \ref{wrap-tab:muster}.
\begin{wraptable}{r}{5cm}
	\begin{center}
		\begin{tabular}{|c|}
			\hline
			1010\\
			\hline
			1001\\
			\hline
			0101\\
			\hline
			0110\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Bitmuster}\label{wrap-tab:muster}
\end{wraptable}

Der Schrittmotor kann nun bewegt werden, indem die Bitmuster nacheinander, unterbrochen durch eine Wartezeit, an den Schrittmotor geschickt werden. 
Die Geschwindigkeit des Schrittmotors kann durch die Wartezeit, die Richtung durch die Reihenfolge der Signale geändert werden.

Zusätzlich ist zu beachten, dass die Belegung mehrerer Pins des Raspberry Pi abwärts erfolgt, d.h. \texttt{RPiDigitalOut(19, 4)} belegt die Pins \texttt{16, 17, 18, 19}. 
Das Speichern von \texttt{BIT(4)} Variablen in einem Array funktioniert in OpenPEARL aktuell noch nicht; aufgrund der wenigen Zustände wurde auf einen Workaround verzichtet.

In diesem Schritt wurde als Modul eine Prozedur entwickelt, die einen spezifizierten Motor um eine spezifizierte Schrittzahl in spezifizierte Richtung bewegt. Die Synchronisation zur gleichzeitigen Ansteuerung beider Motoren erfolgte erst im Gesamtsystem. Das komplette Schrittmotormodul kann im Ordner \emph{Code/Komponenten/Schrittmotor} des \href{https://github.com/OpenPearl-HFUWPV1718/SensorCar}{Repositories} eingesehen werden.\\


\section{Lichtrechen}
Der Lichtrechen ist essenzieller Bestandteil des Autos und ist dafür zuständig die Position des Autos relativ zum vorgegebenen Pfad zu ermitteln. Der Lichtrechen QTR-8A der Marke Pololu besteht aus 8 Reflektionssensoren, die mit infrarot LED’s die Reflexivität des Untergrundes auf einer Linie von ca. 7cm ermitteln. In unseren Anwendungsfall soll der Sensor ein schwatzes Klebeband auf einem hellen Untergrund erkennen und diese Information zur Steuerung des Autos weiterleiten. 

Die Verbindung zum System geschieht über acht separate Datenpins, die jeweils konstant ein einzelnes Bit aussendet das die Ausgabe eines einzelnen Sensors binär repräsentiert. Des Weiteren gibt es noch einen Abschluss für die Stromzufuhr für 5 und 3.3V, einen Pin für die Erdung und einen Pin mit dem die Infrarot-LED’s an oder abgeschaltet werden können. In unserem Aufbau nutzen wir die 5V Stromversorgung und lassen die LED-Steuerungspin unangeschlossen, in welchem Fall die Sensoren dauerhaft eigeschaltet bleiben. 

Im Anschlussplan ist vorgesehen, dass der Lichtrechen über die Datenpins 6 -13 am Raspberry Pi ausgelesen wird.

Bei der Auswertung der Datenpins werden den Pins von rechts nach links Gewichtungen von 4 bis -4 gegeben und jeder Pin der wenig Reflexion misst wird seiner Wertung nach aufsummiert. Diese Summe Wird dann durch die Anzahl des Summanden geteilt und ergibt somit einen Durchschnittswert für die Position des Leitstreifens. Dieses Verfahren schwächt auch fehlerhafte Werte einzelner Sensoren ab.

\section{Farbsensor}
Der Farbsensor TCS 34725 Der Marke Adafruit besitzt einen Sensor, der sowohl einen RGB Farbwert als auch die gesamt Helligkeit ermitteln lässt. Um die Farben Best möglichst zu erkennen besitzt der Sensor eine sehr helle LED mit weißem Licht. In unserem Projekt soll der Farbsensor Farbige Signal-Punkte auf der Strecke erkennen die denen das Auto beispielsweise das Ende der Stecke erkennen soll. 

Verbunden wir der Sensor im Gegensatz zum Lichtrechen erfolgt die Datenverbindung zum Farbsensor über einen I2C-Bus. Des Weiteren Besitzt der Sensor ebenfalls einen Stromverbindung für 5 und 3.3V, eine Erdung und Einen Pin zur Steuerung der LED.

Die Datenpins 2 und 3 am Raspberry Pi sind standartmäßig für diesen Bus vorkonfiguriert. Die Unterstützung von I2C auf dem Raspberry Pi muss aber erst konfiguriert werden. Dazu muss der Befehl “raspi-config“ ausgeführt werden und dort unter “Advanced Options“ Die Unterstützung in Kernel eingeschaltet werden. Zusätzlich musste in der Datei “/boot/config.txt“ noch die Zeile “ dtparam=i2c1=on“ angefügt werden.

Um den Farbsensor in Pearl benutzen zu können musste dafür noch ein Treiben in C++ geschrieben werden. Dieser umfasst die Dateien “TCS34725.cc“, “TCS34725.h“ und “TCS34725.xml“ dieser Treiber wird in eine Headerfile von open Pearl integriert werden und stellt alle Methoden für die Nutzung des Sensors als DATION in OpenPEARL zur Verfügung.

Bei der Auswertung der Rohdaten vom Sensor konvertieren wir die Daten in Standard RGB Werte mit einer Spanne von 0 bis 255.

\section{TCP/IP Socket}
Über das Socket werden die Daten des SensorCars auf einer Webseite angezeigt. Hierbei bekommt das Socket einen html request vom Browser, an den er dann den HTML-Code schickt. Es werden die Geschwindigkeit, die Anzahl der Schritte und die Werte des Lichtrechens und des Farbsensors angezeigt. Es können außerdem Informationen zum Projekt und die Dokumentation aufgerufen werden. 

Die Webseite kann im gleichen Netz über <ipadresse>/index.html aufgerufen werden. Damit die Daten immer aktuell sind, wird die Seite alle zwei Sekunden aktualisiert.

OpenPEARL hat von sich aus keine Möglichkeit ein Socket aufzusetzen. Es musste daher zuerst implementiert werden. Hierzu wurde eine C++ Datei mit dazugehöriger XML Datei geschrieben und dem System hinzugefügt. Die Dateien wurden im Makefile und im "PearlIncludes.h" registriert. 

Man kann nun im Systemteil von OpenPEARL "TcpIpServer(portnummer)" angeben. Die Kommunikation läuft über "DATION INOUT". Somit ist eine beidseitige Kommunikation möglich. 
